options gen2
options no_aot

// Tutorial 17 — Quasi-quotation reference (qmacro variants).
//
// This tutorial demonstrates ALL qmacro variants and reification
// operators available in `daslib/templates_boost`.
//
// The companion module `qmacro_mod.das` defines a single
// [call_macro] named `build_demo` that uses every variant:
//
//   qmacro variants (10 + quote):
//     quote(expr)                       — plain AST capture, no reification
//     qmacro(expr)                      — expression with reification
//     qmacro_type(type<T>)              — build TypeDeclPtr
//     qmacro_variable("n", type<T>)     — build VariablePtr
//     qmacro_expr(${ stmt })            — single statement
//     qmacro_block() { stmts }          — block of statements
//     qmacro_block_to_array() { stmts } — statements → array<ExpressionPtr>
//     qmacro_function("name") $(args) { body }       — full function
//     qmacro_template_class("Name", type<Template>)  — clone struct template
//     qmacro_method("Cls`meth", cls) $(self...) { }   — class method (*)
//     qmacro_template_function(@@fn)                   — clone template fn
//
//   qmacro_method is used here to generate a `get_tuple` method
//   on the cloned DemoIntFloat struct.
//
//   Reification operators:
//     $v(value)   — compile-time value → AST constant
//     $e(expr)    — splice existing ExpressionPtr
//     $i(name)    — string → identifier
//     $c(name)    — string → function call name
//     $f(name)    — string → field access name
//     $t(type)    — splice TypeDeclPtr in type position
//     $a(args)    — splice array<VariablePtr> as parameters
//     $b(body)    — splice array<ExpressionPtr> as block body
//
// See `qmacro_mod.das` for the implementation of each variant.
// The code below exercises the artefacts that the macro generates
// at compile time.

require qmacro_mod

[export]
def main() {
    // build_demo() triggers the call macro.  All functions and structs
    // are registered at compile time via add_function / add_structure.
    // The return value (a trivial constant) is discarded.
    build_demo()

    // 1. demo_run — generated by qmacro_function.
    //    Its body was assembled from qmacro, qmacro_expr, qmacro_block,
    //    qmacro_block_to_array, and reification operators
    //    $v, $e, $i, $c, $f, $a, $b.
    print("--- demo_run ---\n")
    demo_run("test")

    // 2. DemoIntFloat — generated by qmacro_template_class.
    //    Cloned from struct template DemoPair with TFirst=int, TSecond=float.
    print("\n--- DemoIntFloat (qmacro_template_class) ---\n")
    var pair = DemoIntFloat(first = 42, second = 3.14)
    // describe() was a template method on DemoPair — it was cloned
    // and type-substituted automatically by qmacro_template_class.
    pair.describe()

    let (a,b) = pair.get_tuple()
    print("get_tuple() = ({a}, {b})\n")

    // 3. demo_add_int — generated by qmacro_template_function.
    //    Cloned from template demo_add, types fixed to int.
    print("\n--- demo_add_int (qmacro_template_function) ---\n")
    let sum = demo_add_int(10, 20)
    print("demo_add_int(10, 20) = {sum}\n")
}
