# Dynamic Module Descriptors (`.das_module`)

When daslang is built as a dynamic/DLL binary (`daslang`), it cannot use compile-time `NATIVE_MODULE` macros or static linking to resolve modules under `modules/`. Instead, each module directory needs a `.das_module` descriptor — a small daslang script that tells the runtime where to find the module's components.

## Static vs dynamic binary — module resolution

The build produces two binaries:

| Binary | CMake target | How modules resolve |
|--------|-------------|---------------------|
| `daslang_static` | `daslang_static` | `NATIVE_MODULE` macros (compiled from `external_resolve.inc`) + static linking of C++ module libs |
| `daslang` (default) | `daslang` | `.das_module` descriptor scripts + `.shared_module` DLLs |

The static binary compiles `modules/external_resolve.inc` (generated by CMake from `ADD_MODULE_DAS` / `ADD_MODULE_CPP` calls) and links all `libDasModule*` static libraries. It needs no `.das_module` files.

The dynamic binary loads `.das_module` scripts at startup from each `modules/<name>/` directory. These scripts register module paths and shared libraries so the runtime can find them.

### Resolution order in `getModuleInfo()` (`src/simulate/fs_file_info.cpp`)

For a `require foo/bar` statement:
1. Parse: `top="foo"`, `mod_name="bar"`
2. Check if `top` == `"daslib"` → resolve from `daslib/` directory
3. Try `NATIVE_MODULE` macro matches (static binary only — compiled into the binary)
4. Try `g_dyn_modules_resolve` entries (populated by `.das_module` scripts via `register_native_path`)
5. Try `extraRoots` map
6. Try `dastest` module name

## `.das_module` file format

Every `.das_module` is a daslang script with an `initialize` export:

```das
options gen2
require fio

[export]
def initialize(project_path : string) {
    // register modules here
}
```

- `project_path` — absolute path to the module directory (e.g. `/path/to/modules/dasFoo`)
- The file MUST be named `.das_module` (dot-prefixed, no other name)
- The file lives at `modules/<name>/.das_module`

## Two registration functions

### `register_dynamic_module` — for C++ modules with shared libraries

Used when the module has C++ code compiled into a `.shared_module` DLL:

```das
[export]
def initialize(project_path : string) {
    if (das_is_dll_build()) {
        register_dynamic_module("{project_path}/dasModuleFoo.shared_module", "Module_Foo")
    }
}
```

- First arg: path to the `.shared_module` file (string interpolation with `project_path`)
- Second arg: C++ module class name (must match `REGISTER_MODULE(Module_Foo)` in C++)
- Guard with `das_is_dll_build()` — only needed in the dynamic binary
- One call per C++ module class; a single DLL can contain multiple module classes (see dasImgui example below)

### `register_native_path` — for pure-das modules (no C++ component)

Used when the module is implemented entirely in `.das` files:

```das
[export]
def initialize(project_path : string) {
    register_native_path("peg", "peg", "{project_path}/peg/peg.das")
}
```

- First arg (`mod_name`): the top-level module name — the part before `/` in `require foo/bar` → `"foo"`
- Second arg (`from_path`): the part after the first `/` in the require path — for `require foo/bar` → `"bar"`. For `require foo/sub/bar` → `"sub/bar"`
- Third arg (`to_path`): absolute filesystem path to the `.das` file
- Does NOT need `das_is_dll_build()` guard — path registration is harmless in static builds (though it won't be called since static builds don't load `.das_module`)

**Critical**: `from_path` must match `req.substr(np + 1)` from the C++ resolution code. For `require peg/peg`, that's `"peg"`, NOT `"peg/peg"`.

## Examples

### C++ module with one class (dasUnitTest)

```das
options gen2
require fio

[export]
def initialize(project_path : string) {
    if (das_is_dll_build()) {
        register_dynamic_module("{project_path}/dasModuleUnitTest.shared_module", "Module_UnitTest")
    }
}
```

### C++ module with multiple classes (dasImgui)

```das
options gen2
require fio

[export]
def initialize(project_path : string) {
    if (das_is_dll_build()) {
        register_dynamic_module("{project_path}/dasModuleImgui.shared_module", "Module_dasIMGUI")
        register_dynamic_module("{project_path}/dasModuleImgui.shared_module", "Module_dasIMGUI_NODE_EDITOR")
        register_dynamic_module("{project_path}/imguiApp.shared_module", "Module_imgui_app")
    }
}
```

### Pure-das module with multiple files (dasPEG)

```das
options gen2
require fio

[export]
def initialize(project_path : string) {
    let peg_paths = ["peg", "meta_ast", "parse_macro", "parser_generator"]
    for (path in peg_paths) {
        register_native_path("peg", "{path}", "{project_path}/peg/{path}.das")
    }
}
```

### Mixed module with C++ and das paths (dasLLVM)

```das
options gen2
require fio

[export]
def initialize(project_path : string) {
    let daslib_paths = [
        "llvm_boost", "llvm_debug", "llvm_jit", "llvm_targets",
        "llvm_jit_intrin", "llvm_jit_common", "llvm_dll_utils"
    ]
    let bindings_paths = [
        "llvm_const", "llvm_enum", "llvm_func", "llvm_struct",
    ]
    for (path in daslib_paths) {
        register_native_path("llvm", "daslib/{path}", "{project_path}/daslib/{path}.das")
    }
    for (path in bindings_paths) {
        register_native_path("llvm", "bindings/{path}", "{project_path}/bindings/{path}.das")
    }
}
```

## CMake integration

### C++ modules — `ADD_MODULE_LIB` + `ADD_MODULE_CPP`

These CMake macros handle both static and dynamic builds:
- `ADD_MODULE_LIB(libName dllName sources...)` — creates static lib (`libName`) + shared module DLL (`dllName.shared_module`)
- `ADD_MODULE_CPP(ClassName)` — appends `NEED_MODULE(Module_ClassName);` to `external_need.inc`

The `.das_module` file is usually checked into the module directory and handles `register_dynamic_module` calls.

### Pure-das modules — `ADD_MODULE_DAS`

```cmake
ADD_MODULE_DAS(category subfolder native)
```

Appends `NATIVE_MODULE(category, subfolder, module_dir, native);` to `external_resolve.inc`. This handles the static binary. For the dynamic binary, you must also provide a `.das_module` with `register_native_path` calls.

### Install rules for `.das_module`

Add an install rule so the descriptor ships with the SDK:

```cmake
install(FILES ${PROJECT_SOURCE_DIR}/modules/dasFoo/.das_module
        DESTINATION ${DAS_INSTALL_MODULESDIR}/dasFoo)
```

## When to create a `.das_module`

| Module type | Has `.das_module`? | Registration calls |
|---|---|---|
| C++ module (`ADD_MODULE_LIB`) | Yes | `register_dynamic_module` for each C++ module class |
| Pure-das module (`ADD_MODULE_DAS`) | Yes | `register_native_path` for each `.das` file |
| Mixed (C++ + das files) | Yes | Both `register_dynamic_module` and `register_native_path` |
| daslib module (`daslib/*.das`) | No | Resolved via `daslib/` directory convention |

**If you add a new module under `modules/` and it works with the static binary but fails with the dynamic binary** (error: "missing prerequisite"), you need a `.das_module` descriptor.

## Debugging module resolution

- Static binary (`daslang_static`): if `require foo/bar` fails, check that `ADD_MODULE_DAS(foo, subfolder, bar)` exists in the module's `CMakeLists.txt` and rebuild
- Dynamic binary (`daslang`): if `require foo/bar` fails, check that `modules/dasFoo/.das_module` exists and contains a matching `register_native_path("foo", "bar", ...)` or `register_dynamic_module(...)` call
- Use `das_is_dll_build()` to check at runtime whether running in the dynamic binary
- The `.shared_module` extension is used for C++ module DLLs — NOT `.das_module` (that's the descriptor script)
