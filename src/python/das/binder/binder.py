import logging
import argparse
import json
import sys
from os import path
from das.shared.object_base import LoggingObject
from das.shared.op_sys import full_path, run_exec, write_to_file


APP_NAME = 'dasBinder'


class BinderError(Exception):
    pass


class Settings(object):

    def __init__(self, argv):
        self.__args = self.__parse_argv(argv=argv)

    @classmethod
    def __parse_argv(cls, argv):
        parser = argparse.ArgumentParser(
            description='Generates das::Module binding stuff from .h file.')
        parser.add_argument('--c_header_from', type=str, required=True,
            help='.h file to generate bindings from.')
        parser.add_argument('--module_to', type=str, required=True,
            help='.cpp file to write generated das::Module to.')
        parser.add_argument('--clang_c_exe', type=str, default='clang',
            help='Clang C compiler to use. Default: %(default)s')
        parser.add_argument('--include_dirs', type=str,
            help='Additional "include" directories to use.')
        parser.add_argument('--include_dirs_sep', type=str, default=';',
            help='Separator used in "--include_dirs".')
        parser.add_argument('--config', type=str, required=True,
            help='Path to binding config.')
        parser.add_argument('--log_level', type=str,
            choices=['debug', 'info', 'warning', 'error'],
            default='info', help='Logging level. Default: %(default)s')
        return parser.parse_args(argv)

    @property
    def log_level(self):
        return getattr(logging, self.__args.log_level.upper())

    @property
    def module_to(self):
        return full_path(self.__args.module_to)

    @property
    def c_header_from(self):
        return full_path(self.__args.c_header_from)

    @property
    def clang_c_exe(self):
        return self.__args.clang_c_exe

    @property
    def include_dirs(self):
        return self.__args.include_dirs.split(self.__args.include_dirs_sep)

    @property
    def config_fpath(self):
        return full_path(self.__args.config)


class Binder(LoggingObject):

    def __init__(self, argv):
        self.__settings = Settings(argv=argv[1:])
        self.__config = self.__read_config(self.__settings.config_fpath)
        self.__c_header = None

    def run(self):
        logging.basicConfig(level=self.__settings.log_level,
            format='%(asctime)s [%(levelname)s:%(name)s] %(message)s')
        self._log_info(f'Generating bindings for '
            f'{self.__settings.c_header_from}')
        self.__c_header = C_TranslationUnit(
            c_src_fpath=self.__settings.c_header_from,
            clang_c_exe=self.__settings.clang_c_exe,
            include_dirs=self.__settings.include_dirs,
            config=self.__config)
        write_to_file(fpath=self.__settings.module_to,
            content='\n'.join(self.__generate_module() + ['']))
        self._log_info(f'Wrote generated das::Module to '
            f'{self.__settings.module_to}')
        self._log_info('Finished successfully.')

    def __read_config(self, config_fpath):
        cfg_globals = {}
        try:
            with open(config_fpath, 'r') as f:
                cfg_py = f.read()
        except IOError:
            raise BinderError(f'Could not read config file: {config_fpath}')
        exec(cfg_py, cfg_globals)
        config_class = cfg_globals.get('Config')
        if config_class is None:
            raise BinderError(f'Config file must define "Config" class.')
        return config_class()

    def __generate_module(self):
        lines = []
        module = self.__config.das_module_name
        include = self.__config.c_header_include
        lines += [
           f'// generated by {APP_NAME}',
            '',
            '#include "daScript/daScript.h"',
            '',
           f'#include "{include}"',
            '',
            'using namespace das;',
        ]
        lines += [
            '',
            '//',
            '// enums',
            '//',
            ''] + [
            line for enum in self.__c_header.enums
                for line in enum.generate_decl()
        ]
        lines += [
            '',
            '//',
            '// structs',
            '//',
            ''] + [
            line for struct in self.__c_header.structs
                for line in struct.generate_decl()
        ]
        lines += [
            '',
           f'class Module_{module} : public Module {{',
            'public:',
           f'    Module_{module}() : Module("{module}") {{',
            '        ModuleLibrary lib;',
            '        lib.addModule(this);',
            '        lib.addBuiltInModule();'
        ]
        lines += [
            '',
            '        //',
            '        // enums',
            '        //',
            ''] + [
           f'        {line}' for enum in self.__c_header.enums
                        for line in enum.generate_add()
        ]
        lines += [
            '',
            '        //',
            '        // structs',
            '        //',
            ''] + [
           f'        {line}' for struct in self.__c_header.structs
                        for line in struct.generate_add()
        ]
        lines += [
            '    }',
            '};',
            '',
            f'REGISTER_MODULE(Module_{module});',
        ]
        return lines


class C_TranslationUnit(LoggingObject):

    def __init__(self, c_src_fpath, clang_c_exe, include_dirs, config):
        cmd = []
        cmd += [clang_c_exe, '-cc1', '-ast-dump=json']
        for dpath in include_dirs:
            cmd += [f'-I{dpath}']
        cmd += [c_src_fpath]
        out, err, exit_code = run_exec(cmd)
        self.__root = json.loads(out)
        self.__config = config

        self.__all_enums = list(self.__get_nodes(node_class=C_Enum,
            configure_fn=self.__config.configure_enum))
        self.__all_structs = list(self.__get_nodes(node_class=C_Struct,
            configure_fn=self.__config.configure_struct))

        # Ignoring all types which depend on ignored types
        self.__ignored_types = set()
        while True:
            self.__ignored_types = set(node.name
                for nodes in [self.__all_enums, self.__all_structs]
                for node in nodes
                if node.is_ignored)
            anything_new_ignored = False
            for struct in self.__all_structs:
                if (not struct.is_ignored
                    and struct.depends_on(self.__ignored_types)
                ):
                    struct.ignore()
                    anything_new_ignored = True
            if not anything_new_ignored:
                break

        self._log_info('Ignoring following types:\n{}'.format('\n'.join(
            sorted(self.__ignored_types))))

    def __get_nodes(self, node_class, configure_fn):
        for inner in self.__root['inner']:
            node = node_class.maybe_create(root=inner)
            if node is None or node.is_builtin:
                continue
            configure_fn(node)
            yield node

    @property
    def enums(self):
        for enum in self.__all_enums:
            if not enum.is_ignored:
                yield enum

    @property
    def structs(self):
        for struct in self.__all_structs:
            if not struct.is_ignored:
                yield struct


class C_InnerNode(object):

    def __init__(self, root):
        self.__root = root
        self.__ignored = False

    def ignore(self):
        self.__ignored = True

    @property
    def is_ignored(self):
        return self.__ignored

    @property
    def is_builtin(self):
        return self.name.startswith('_')

    @property
    def root(self):
        return self.__root

    @property
    def name(self):
        return self.root['name']

    def generate_decl(self):
        return []

    def generate_add(self):
        return []


class C_Enum(C_InnerNode):

    @staticmethod
    def maybe_create(root):
        if root['kind'] == 'EnumDecl':
            return C_Enum(root=root)

    @property
    def fields(self):
        for inner in self.root['inner']:
            if inner['kind'] == 'EnumConstantDecl':
                yield inner['name']

    def generate_decl(self):
        lines = []
        lines += [f'DAS_BIND_ENUM_CAST({self.name});']
        lines += [f'DAS_BASE_BIND_ENUM({self.name}, {self.name}']
        lines += [f',   {f}' for f in self.fields]
        lines += [')']
        return lines

    def generate_add(self):
        return [f'addEnumeration(make_smart<Enumeration{self.name}>());']


class C_Struct(C_InnerNode):

    def __init__(self, **kwargs):
        super(C_Struct, self).__init__(**kwargs)
        self.__is_local = True
        self.__can_copy = True
        self.__can_move = True

    def set_is_local(self, is_local):
        self.__is_local = is_local

    def set_can_copy(self, can_copy):
        self.__can_copy = can_copy

    def set_can_move(self, can_move):
        self.__can_move = can_move

    @staticmethod
    def maybe_create(root):
        if (root['kind'] == 'RecordDecl'
            and root['tagUsed'] == 'struct'
            and 'inner' in root
        ):
            return C_Struct(root=root)

    @property
    def fields(self):
        for inner in self.root['inner']:
            if inner['kind'] == 'FieldDecl':
                yield C_StructField(root=inner)

    def depends_on(self, types):
        for type_ in types:
            for field in self.fields:
                if type_ in field.type:
                    return True
        return False

    def generate_decl(self):
        is_local = to_cpp_bool(self.__is_local)
        can_copy = to_cpp_bool(self.__can_copy)
        can_move = to_cpp_bool(self.__can_move)
        lines = []
        lines += [
           f'MAKE_TYPE_FACTORY({self.name}, {self.name});',
           f'struct {self.name}Annotation',
           f': public ManagedStructureAnnotation<{self.name},true,true> {{',
           f'    {self.name}Annotation(ModuleLibrary & ml)',
           f'    : ManagedStructureAnnotation ("{self.name}", ml) {{',
        ]
        lines += [
           f'        addField<DAS_BIND_MANAGED_FIELD({f.name})>("{f.name}");'
                        for f in self.fields
        ]
        lines += [
            '    }',
           f'    virtual bool isLocal() const override {{ return {is_local}; }}',
           f'    virtual bool canCopy() const override {{ return {can_copy}; }}',
           f'    virtual bool canMove() const override {{ return {can_move}; }}',
            '};'
        ]
        return lines

    def generate_add(self):
        return [f'addAnnotation(make_smart<{self.name}Annotation>(lib));']


class C_StructField(C_InnerNode):

    @property
    def type(self):
        t = self.root['type']
        return t.get('desugaredQualType', t['qualType'])

    @property
    def is_array(self):
        return '[' in self.type

    @property
    def is_bit_field(self):
        return self.root.get('isBitfield', False)


def to_cpp_bool(b):
    return {True: 'true', False: 'false'}[b]
