// this file is generated via daScript automatic C++ binder
// all user modifications will be lost after this file is re-generated

template <> struct cast_arg<CXString> {
	static __forceinline const CXString & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXString *>::to(res);
	}
};
template <> struct cast_arg<CXStringSet> {
	static __forceinline const CXStringSet & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXStringSet *>::to(res);
	}
};
template <> struct cast_arg<CXUnsavedFile> {
	static __forceinline const CXUnsavedFile & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXUnsavedFile *>::to(res);
	}
};
template <> struct cast_arg<CXVersion> {
	static __forceinline const CXVersion & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXVersion *>::to(res);
	}
};
template <> struct cast_arg<CXFileUniqueID> {
	static __forceinline const CXFileUniqueID & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXFileUniqueID *>::to(res);
	}
};
template <> struct cast_arg<CXSourceLocation> {
	static __forceinline const CXSourceLocation & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXSourceLocation *>::to(res);
	}
};
template <> struct cast_arg<CXSourceRange> {
	static __forceinline const CXSourceRange & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXSourceRange *>::to(res);
	}
};
template <> struct cast_arg<CXSourceRangeList> {
	static __forceinline const CXSourceRangeList & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXSourceRangeList *>::to(res);
	}
};
template <> struct cast_arg<CXTUResourceUsageEntry> {
	static __forceinline const CXTUResourceUsageEntry & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXTUResourceUsageEntry *>::to(res);
	}
};
template <> struct cast_arg<CXTUResourceUsage> {
	static __forceinline const CXTUResourceUsage & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXTUResourceUsage *>::to(res);
	}
};
template <> struct cast_arg<CXCursor> {
	static __forceinline const CXCursor & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXCursor *>::to(res);
	}
};
template <> struct cast_arg<CXPlatformAvailability> {
	static __forceinline const CXPlatformAvailability & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXPlatformAvailability *>::to(res);
	}
};
template <> struct cast_arg<CXType> {
	static __forceinline const CXType & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXType *>::to(res);
	}
};
template <> struct cast_arg<CXToken> {
	static __forceinline const CXToken & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXToken *>::to(res);
	}
};
template <> struct cast_arg<CXCompletionResult> {
	static __forceinline const CXCompletionResult & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXCompletionResult *>::to(res);
	}
};
template <> struct cast_arg<CXCodeCompleteResults> {
	static __forceinline const CXCodeCompleteResults & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXCodeCompleteResults *>::to(res);
	}
};
template <> struct cast_arg<CXCursorAndRangeVisitor> {
	static __forceinline const CXCursorAndRangeVisitor & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXCursorAndRangeVisitor *>::to(res);
	}
};
template <> struct cast_arg<CXIdxLoc> {
	static __forceinline const CXIdxLoc & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxLoc *>::to(res);
	}
};
template <> struct cast_arg<CXIdxIncludedFileInfo> {
	static __forceinline const CXIdxIncludedFileInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxIncludedFileInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxImportedASTFileInfo> {
	static __forceinline const CXIdxImportedASTFileInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxImportedASTFileInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxAttrInfo> {
	static __forceinline const CXIdxAttrInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxAttrInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxEntityInfo> {
	static __forceinline const CXIdxEntityInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxEntityInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxContainerInfo> {
	static __forceinline const CXIdxContainerInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxContainerInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxIBOutletCollectionAttrInfo> {
	static __forceinline const CXIdxIBOutletCollectionAttrInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxIBOutletCollectionAttrInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxDeclInfo> {
	static __forceinline const CXIdxDeclInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCContainerDeclInfo> {
	static __forceinline const CXIdxObjCContainerDeclInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCContainerDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxBaseClassInfo> {
	static __forceinline const CXIdxBaseClassInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxBaseClassInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCProtocolRefInfo> {
	static __forceinline const CXIdxObjCProtocolRefInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCProtocolRefInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCProtocolRefListInfo> {
	static __forceinline const CXIdxObjCProtocolRefListInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCProtocolRefListInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCInterfaceDeclInfo> {
	static __forceinline const CXIdxObjCInterfaceDeclInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCInterfaceDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCCategoryDeclInfo> {
	static __forceinline const CXIdxObjCCategoryDeclInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCCategoryDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxObjCPropertyDeclInfo> {
	static __forceinline const CXIdxObjCPropertyDeclInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxObjCPropertyDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxCXXClassDeclInfo> {
	static __forceinline const CXIdxCXXClassDeclInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxCXXClassDeclInfo *>::to(res);
	}
};
template <> struct cast_arg<CXIdxEntityRefInfo> {
	static __forceinline const CXIdxEntityRefInfo & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<CXIdxEntityRefInfo *>::to(res);
	}
};
template <> struct cast_arg<IndexerCallbacks> {
	static __forceinline const IndexerCallbacks & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<IndexerCallbacks *>::to(res);
	}
};
