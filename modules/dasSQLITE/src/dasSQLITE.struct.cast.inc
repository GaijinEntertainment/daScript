// this file is generated via daScript automatic C++ binder
// all user modifications will be lost after this file is re-generated

template <> struct cast_arg<sqlite3_file> {
	static __forceinline const sqlite3_file & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_file *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_io_methods> {
	static __forceinline const sqlite3_io_methods & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_io_methods *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_vfs> {
	static __forceinline const sqlite3_vfs & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_vfs *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_mem_methods> {
	static __forceinline const sqlite3_mem_methods & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_mem_methods *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_module> {
	static __forceinline const sqlite3_module & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_module *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_index_info::sqlite3_index_constraint> {
	static __forceinline const sqlite3_index_info::sqlite3_index_constraint & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_index_info::sqlite3_index_constraint *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_index_info::sqlite3_index_orderby> {
	static __forceinline const sqlite3_index_info::sqlite3_index_orderby & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_index_info::sqlite3_index_orderby *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_index_info::sqlite3_index_constraint_usage> {
	static __forceinline const sqlite3_index_info::sqlite3_index_constraint_usage & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_index_info::sqlite3_index_constraint_usage *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_index_info> {
	static __forceinline const sqlite3_index_info & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_index_info *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_vtab> {
	static __forceinline const sqlite3_vtab & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_vtab *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_vtab_cursor> {
	static __forceinline const sqlite3_vtab_cursor & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_vtab_cursor *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_mutex_methods> {
	static __forceinline const sqlite3_mutex_methods & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_mutex_methods *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_pcache_page> {
	static __forceinline const sqlite3_pcache_page & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_pcache_page *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_pcache_methods2> {
	static __forceinline const sqlite3_pcache_methods2 & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_pcache_methods2 *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_pcache_methods> {
	static __forceinline const sqlite3_pcache_methods & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_pcache_methods *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_snapshot> {
	static __forceinline const sqlite3_snapshot & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_snapshot *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_rtree_geometry> {
	static __forceinline const sqlite3_rtree_geometry & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_rtree_geometry *>::to(res);
	}
};
template <> struct cast_arg<sqlite3_rtree_query_info> {
	static __forceinline const sqlite3_rtree_query_info & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<sqlite3_rtree_query_info *>::to(res);
	}
};
template <> struct cast_arg<Fts5PhraseIter> {
	static __forceinline const Fts5PhraseIter & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Fts5PhraseIter *>::to(res);
	}
};
template <> struct cast_arg<Fts5ExtensionApi> {
	static __forceinline const Fts5ExtensionApi & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<Fts5ExtensionApi *>::to(res);
	}
};
template <> struct cast_arg<fts5_tokenizer> {
	static __forceinline const fts5_tokenizer & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<fts5_tokenizer *>::to(res);
	}
};
template <> struct cast_arg<fts5_api> {
	static __forceinline const fts5_api & to ( Context & ctx, SimNode * node ) {
		vec4f res = node->eval(ctx);
		return * cast<fts5_api *>::to(res);
	}
};
