options indenting = 4
options no_global_variables = false
options no_unused_block_arguments = false
options no_unused_function_arguments = false
options persistent_heap = true
options persistent_string_heap = true
module debug shared

require math
require strings
require rtti
require debugapi
require fio
require network
require uriparser

require daslib/json
require daslib/json_boost
require daslib/defer
require daslib/apply_in_context
require daslib/jobque_boost
require daslib/strings_boost
require daslib/dap


let private
    LOCAL_VARS = 1ul
    ARGUMENT_VARS = 2ul
    GLOBAL_VARS = 3ul

    MAX_STACK = 1000ul
    MAX_VARIABLES = 100000ul

    print_flags_debug = (
            print_flags escapeString
        |   print_flags namesAndDimensions
        |   print_flags singleLine
        // |   print_flags humanReadable
        // |   print_flags typeQualifiers
        // |   print_flags refAddresses
    )

def private ctx_at(var ctx: Context): DAContextAt
    unsafe
        return intptr(addr(ctx))

def private get_int_arg(args: array<string>; name: string; def_val: int): int
    let idx = find_index(args, name)
    return idx >= 0 && idx + 1 < length(args) ? int(args[idx + 1]) : def_val

def private ends_with_separator(str: string): bool
    for c in "\\/"
        if ends_with(str, to_char(c))
            return true
    return false

def private starts_with_separator(str: string): bool
    for c in "\\/"
        if starts_with(str, to_char(c))
            return true
    return false

def private trim_path(path: string): string
    if path == "."
        return ""
    if path |> starts_with("./") || path |> starts_with(".\\")
        return path |> slice(2)
    return path

def private join_path(a, path_b: string): string
    let b = trim_path(path_b)
    if length(a) == 0
        return fix_path(b)
    if length(b) == 0
        return fix_path(a)
    var res = build_string() <| $(builder)
        builder |> write(a)
        let ends = ends_with_separator(a)
        let starts = starts_with_separator(b)
        if ends && starts
            builder |> write(slice(b, 1))
        elif !ends && !starts
            builder |> write("/")
            builder |> write(b)
        else
            builder |> write(b)
    return fix_path(res)

def private fix_path(path: string): string
    return path |> trim_path() |> file_name_to_uri() |> normalize_uri() |> uri_to_file_name()

def private resolve_path(path: string; paths: array<string>): string
    if path |> empty()
        return path
    for it in paths
        let newPath = it |> join_path(path)
        if stat(newPath).is_valid
            return newPath
    return fix_path(path)


def private bytes_hr(value : uint64)
    if value > uint64(1024 * 1024)
        return "{float(value) / (1024f * 1024f)}mb ({int(value)})"
    if value > uint64(1024)
        return "{float(value) / 1024f}kb ({int(value)})"
    return "{int(value)} b"


class DAWalker: DapiDataWalker
    varsStack: array<DAVariable?>
    [[do_not_delete]] frame: DAStackFrame?
    visited: array<tuple<ps: void?; hash: uint>>

    def startWalk(var f: DAStackFrame; var v: DAVariable)
        unsafe
            frame = addr(f)
            varsStack |> push(addr(v))

    def endWalk()
        varsStack |> clear()

    def popStack()
        let n = length(varsStack)
        if n > 1
            varsStack |> erase(n - 1)

    def startCont()
        let n = length(varsStack)
        if varsStack[n-1].children == null
            varsStack[n-1].children = new [[array<DAVariable>]]

    def override canVisitStructure(ps: void?; si: StructInfo): bool
        for vis in visited
            if vis.ps == ps && vis.hash == si.hash
                return false
        return true

    def override beforeStructure(ps: void?; si: StructInfo): void
        visited |> emplace([[auto ps, si.hash]])

    def override afterStructure(ps: void?; si: StructInfo): void
        visited |> erase(length(visited) - 1)

    def override afterStructureCancel(ps: void?; si: StructInfo): void
        visited |> erase(length(visited) - 1)

    def override beforeStructureField(ps:void?; si: StructInfo; pv: void?; vi:VarInfo; last: bool): void
        self->startCont()
        let n = length(varsStack)
        if n > 0
            var ti = type_info(vi)
            let value = sprint_data(pv, ti, print_flags_debug)
            var stack & = varsStack[n - 1]
            *stack.children |> emplace([[DAVariable uid=frame.varId++, name="{vi.name}", value=value, _type=describe(ti)]])
            unsafe
                varsStack |> push(addr((*stack.children)[length(*stack.children) - 1]))

    def override afterStructureField(ps:void?; si: StructInfo; pv: void?; vi:VarInfo; last: bool): void
        self->popStack()

    def override beforeArrayElement(ps: void?; ti: TypeInfo; pe: void?; index: uint; last: bool): void
        self->startCont()
        let n = length(varsStack)
        if n > 0
            var value: string
            var _type: string
            unsafe
                value = sprint_data(pe, addr(ti), print_flags_debug)
                _type = describe(addr(ti))
            var stack & = varsStack[n - 1]
            *stack.children |> emplace([[DAVariable uid=frame.varId++, name="{int64(index)}", value=value, _type=_type]])
            unsafe
                varsStack |> push(addr((*stack.children)[length(*stack.children) - 1]))

    def override afterArrayElement(ps: void?; ti: TypeInfo; pe: void?; index: uint; last: bool): void
        self->popStack()


struct private DAVariable
    uid: uint64
    name: string
    value: string
    _type: string
    children: array<DAVariable>?


def find_child_var(val: DAVariable; id: uint64; cb: block<(res:DAVariable): void>)
    if val.uid == id
        cb |> invoke(val)
        return true
    if val.children != null
        for c in *val.children
            if c |> find_child_var(id, cb)
                return true
    return false


struct private DAStackFrame
    name: string
    path: string
    line: uint = 1u
    variables: array<DAVariable>
    arguments: array<DAVariable>
    globals: array<DAVariable>

    varId: uint64 = GLOBAL_VARS + 1ul


def find_child_var(stack: DAStackFrame; id: uint64; cb: block<(res:DAVariable): void>)
    for c in stack.variables
        if c |> find_child_var(id, cb)
            return
    for c in stack.arguments
        if c |> find_child_var(id, cb)
            return
    for c in stack.globals
        if c |> find_child_var(id, cb)
            return


class private DAStackWalker: DapiStackWalker
    dataWalkerAdapter: smart_ptr<DataWalker>
    dataWalker: DAWalker?

    [[do_not_delete]] ctx: DAContext?
    [[do_not_delete]] workingPaths: array<string>?

    def DAStackWalker()
        dataWalker = new DAWalker()
        unsafe
            dataWalkerAdapter <- make_data_walker(dataWalker)

    def finalize()
        unsafe
            delete dataWalkerAdapter
            delete dataWalker

    def collectGlobals()
        let stackLen = length(ctx.stack)
        if stackLen == 0
            return
        for i in range(get_total_variables(*ctx.ctx))
            let vinfo & = get_variable_info(ctx.ctx, i)
            var value: void?
            unsafe
                value = get_context_global_variable(ctx.ctx, vinfo.name)
            let ti = type_info(vinfo)

            var frame & = ctx.stack[stackLen - 1]
            var global = [[DAVariable uid=frame.varId++, name="{vinfo.name}", value=sprint_data(value, ti, print_flags_debug), _type=describe(ti)]]

            if ti != null
                dataWalker->startWalk(frame, global)
                dataWalkerAdapter |> walk_data(value, *ti)
                dataWalker->endWalk()

            frame.globals |> emplace(global)

    def override onCallAOT(pp:Prologue; fileName:string#): void
        // print("AOT {fileName}\n")
        ctx.stack |> emplace([[DAStackFrame() name="aot {pp.info.name}", path = "{fileName}" ]])
        self->collectGlobals()

    def override onCallAt(pp:Prologue; info:FuncInfo; at:LineInfo): void
        // print("def {info.name} at {at}\n")
        ctx.stack |> emplace([[DAStackFrame() name="def {info.name}", path="{at.fileInfo.name}" |> resolve_path(*workingPaths), line=at.line ]])
        self->collectGlobals()

    def override onCall(pp:Prologue; info:FuncInfo): void
        // print("def {info.name}\n")
        ctx.stack |> emplace([[DAStackFrame() name="def {info.name}" ]])
        self->collectGlobals()

    def override onVariable(inf: FuncInfo; vinfo: LocalVariableInfo; arg: void?; inScope: bool): void
        let stackLen = length(ctx.stack)
        if stackLen > 0
            var frame & = ctx.stack[stackLen - 1]
            var ti = type_info(vinfo)
            let value = !inScope ? "<out of scope>" : arg != null ? sprint_data(arg, ti, print_flags_debug): "<optimized>"
            var variable = [[DAVariable uid=frame.varId++, name="{vinfo.name}", value=value, _type=describe(ti)]]
            if ti != null
                dataWalker->startWalk(frame, variable)
                dataWalkerAdapter |> walk_data(arg, *ti)
                dataWalker->endWalk()

            frame.variables |> emplace(variable)

    def override onArgument (inf: FuncInfo; index: int; vinfo: VarInfo; arg: float4)
        let stackLen = length(ctx.stack)
        if  stackLen > 0
            var frame & = ctx.stack[stackLen-1]
            let ti = type_info(vinfo)
            let value = sprint_data(arg, ti, print_flags_debug)
            var variable = [[DAVariable uid=frame.varId++, name="{vinfo.name}", value=value, _type=describe(ti)]]
            if ti != null
                dataWalker->startWalk(frame, variable)
                dataWalkerAdapter |> walk_data(arg, *ti)
                dataWalker->endWalk()

            frame.arguments |> emplace(variable)


struct private DABreakpoint
    id: uint64
    line: uint

typedef
    DABreakpoints = table<string; array<DABreakpoint>>
    DAContextAt = uint64

struct private DAContext
    id: uint64
    at: DAContextAt
    ctx: Context?
    stack: array<DAStackFrame>
    continueRequested: bool = false
    pauseRequested: bool = false
    stepInRequested: bool = false
    stepRequestedStack: int = 0 // stack depth


def private reset_debug_flags(var ctx: DAContext)
    ctx.continueRequested = false
    ctx.pauseRequested = false
    ctx.stepInRequested = false
    ctx.stepRequestedStack = 0


def private to_string(ctx: DAContext)
    return build_string() <| $(str)
        let stoppable = (uint(ctx.ctx.category) & (1u << 31u)) != 0u
        if stoppable
            str |> write("*")
        let ctxNameLen = length(ctx.ctx.name)
        if ctxNameLen > 0
            str |> write(ctx.ctx.name)
        else
            str |> write(ctx.at)
        if int(ctx.ctx.category) > 0
            str |> write(" ")
            str |> write(ctx.ctx.category)
        if ctxNameLen > 0
            str |> write(" ")
            str |> write(ctx.at)
        str |> write(" (")
        str |> write(int64(ctx.id))
        str |> write(")")


class private DAgent: DapiDebugAgent

    walkerAdapter: smart_ptr<StackWalker>
    walker: DAStackWalker?
    server: DAServer?

    breakpoints: DABreakpoints
    breakpointId: uint64 = 1ul

    contexts: array<DAContext>
    contextId: uint64 = 1ul

    waitConnection: bool = true
    workingPaths: array<string>

    logStrMemory = false
    initialStrLimit = uint64(2 * 1024 * 1024)
    strLimit: uint64 = uint64(2 * 1024 * 1024)

    def DAgent()
        let args <- get_command_line_arguments()
        waitConnection = args |> find_index("--das-wait-debugger") >= 0

        for i in range(length(args) - 1)
            if args[i] == "--das-debug-path"
                workingPaths |> push(args[i + 1])
        let dasRoot = get_das_root()
        workingPaths |> push(dasRoot |> join_path("daslib"))
        workingPaths |> push(dasRoot |> join_path("src/builtin"))

        walker = new DAStackWalker()
        unsafe
            walkerAdapter <- make_stack_walker(walker)
            walker.workingPaths = addr(workingPaths)
        self->startServer()
        self->addContext(this_context())

    def startServer()
        let args <- get_command_line_arguments()
        let port = args |> get_int_arg("--das-debug-port", 10000)
        server = new DAServer()
        server.port = port
        unsafe
            server.agent = addr(self)
        if !server->init(port)
            print("server failed to initialize\n")
            unsafe
                delete server

    def override onUninstall(agent:DebugAgent?)
        if agent == thisAgent
            delete self

    def finalize()
        unsafe
            delete walkerAdapter
            delete walker
            delete server

    def log(msg: string)
        if server != null
            server->log(msg)
        else
            print("{msg}\n")

    def override onBreakpoint(var ctx:Context; at:LineInfo): void
        if at.fileInfo == null
            return
        if server == null
            return
        if !waitConnection && (!server.configurationDone || !server.threadsDone)
            return
        let path = "{at.fileInfo.name}" |> resolve_path(workingPaths)
        self->log("{ctx} breakpoint at {path}:{int(at.line)}\n")
        set_single_step(ctx,true)

        self->addContext(ctx)
        self->getContextDataFor(ctx) <| $(var ctxData: DAContext)
            self->sendStopped(ctx, ctxData, path, at, "pause", -1ul)
            ctxData.continueRequested = false
            while !ctxData.continueRequested && !ctxData.stepInRequested && ctxData.stepRequestedStack == 0
                tick_debug_agent()
                sleep(1u)
            ctxData.continueRequested = false

    def override onSingleStep(var ctx:Context; at:LineInfo): void
        if at.fileInfo == null
            return
        if server == null
            return

        // unsafe
        //     self->log("{double(ctx_at(ctx))} step at {string(at.fileInfo.name) |> resolve_path(workingPaths)}:{int(at.line)}\n")

        if (uint(ctx.category) & (1u << 31u)) != 0u
            self->addContext(ctx)

        if waitConnection && (!server.configurationDone || !server.threadsDone)
            if (uint(ctx.category) & (1u << 31u)) != 0u
                while !server.configurationDone || !server.threadsDone
                    tick_debug_agent()
                    sleep(1u)
            else
                self->log("[Error] non debug context in single step {ctx.name}")

        self->getContextDataFor(ctx) <| $(var ctxData: DAContext)
            let file = string(at.fileInfo.name) |> resolve_path(workingPaths)
            if ctxData.pauseRequested
                self->sendStopped(ctx, ctxData, file, at, "pause", -1ul)
                while ctxData.pauseRequested
                    tick_debug_agent()
                    sleep(1u)

            if ctxData.stepInRequested
                ctxData.stepInRequested = false
                self->sendStopped(ctx, ctxData, file, at, "step", -1ul)
                ctxData.continueRequested = false
                while !ctxData.continueRequested && !ctxData.stepInRequested && ctxData.stepRequestedStack == 0
                    tick_debug_agent()
                    sleep(1u)
                ctxData.continueRequested = false

            if ctxData.stepInRequested
                return

            if ctxData.stepRequestedStack > 0
                if stack_depth(*ctxData.ctx) > ctxData.stepRequestedStack
                    return
                ctxData.stepRequestedStack = 0
                self->sendStopped(ctx, ctxData, file, at, "step", -1ul)
                while !ctxData.continueRequested && !ctxData.stepInRequested && ctxData.stepRequestedStack == 0
                    tick_debug_agent()
                    sleep(1u)

            var prevBreak = -1ul
            var inBreak = key_exists(breakpoints, file)
            // self->log("search break `{file}`:{at.line} - {inBreak}\n")
            while inBreak
                inBreak = false
                let brs = breakpoints |> find(file)
                var brIdx = 0
                while brs != null && brIdx < length(*brs)
                    let br & = (*brs)[brIdx++]
                    // self->log("search break `{file}` {brs} in {file}\n")
                    if br.line == uint(at.line)
                        if ctxData.continueRequested && prevBreak == br.id
                            ctxData.continueRequested = false
                            continue
                        if ctxData.stepInRequested || ctxData.stepRequestedStack > 0
                            continue

                        inBreak = true

                        if prevBreak != br.id
                            self->sendStopped(ctx, ctxData, file, at, "breakpoint", br.id)

                        prevBreak = br.id
                        tick_debug_agent()
                        sleep(1u)
                        break

    def nextStep(var ctx: Context; var ctxData:DAContext; path: string; at:LineInfo)
        delete ctxData.stack
        unsafe
            walker.ctx = addr(ctxData)
        walkerAdapter |> walk_stack(ctx, at)
        if length(ctxData.stack) > 0
            for i in range(1, length(ctxData.stack))
                let j = length(ctxData.stack) - 1
                let q = j - 1
                ctxData.stack[j].path = ctxData.stack[q].path
                ctxData.stack[j].line = ctxData.stack[q].line
            ctxData.stack[0].path = path
            ctxData.stack[0].line = at.line

    def sendStopped(var ctx: Context; var ctxData:DAContext; path: string; at:LineInfo; reason: string; brId: uint64)
        self->log("<< stopped `{reason}` at {path}:{int(at.line)}")

        self->nextStep(ctx, ctxData, path, at)
        server->sendStopped(ctxData, reason, brId)

    def override onTick()
        if server != null
            if !server.disconnected
                server->tick()
            else
                waitConnection = false
                unsafe
                    delete server
                self->startServer()

        var alloc = string_heap_bytes_allocated()
        if alloc > strLimit
            // string_heap_report()
            var report: string
            if logStrMemory
                report = "STRING HEAP COLLECT: {bytes_hr(alloc)} -> "
            unsafe
                string_heap_collect()
            alloc = string_heap_bytes_allocated()
            if logStrMemory
                print("dap: {report}{bytes_hr(alloc)} limit : {bytes_hr(strLimit)}\n")
            if alloc > strLimit
                strLimit *= uint64(2)
                if logStrMemory
                    print("dap: UP string heap limit: {bytes_hr(strLimit)}\n")
            elif strLimit > initialStrLimit && alloc < strLimit / uint64(2)
                strLimit = strLimit / uint64(2)
                if logStrMemory
                    print("dap: DOWN string heap limit: {bytes_hr(strLimit)}\n")

    def override onCreateContext(var ctx: Context): void
        self->addContext(ctx)

    def override onDestroyContext(var ctx: Context): void
        self->removeContext(ctx)

    def getContextDataFor(var ctx: Context; cb: block<(var ctx: DAContext): void>): bool
        let at = ctx_at(ctx)
        for i in iter_range(contexts)
            if contexts[i].at == at
                cb |> invoke(contexts[i])
                return true
        return false

    def getContextData(id: DAContextAt; cb: block<(var ctx: DAContext): void>): bool
        for i in iter_range(contexts)
            if contexts[i].id == id
                cb |> invoke(contexts[i])
                return true
        return false

    def getContextIdx(var ctx: Context): int
        var ctxAt = ctx_at(ctx)
        for idx in iter_range(contexts)
            if contexts[idx].at == ctxAt
                return idx
        return -1

    def addContext(var ctx: Context): bool
        let idx = self->getContextIdx(ctx)
        if idx >= 0
            return false
        unsafe
            contexts |> emplace([[DAContext at=ctx_at(ctx), id=contextId, ctx=addr(ctx)]], 0)
        contextId += 1ul
        contexts |> sort <| $(a, b: DAContext)
            let aid = uint(a.ctx.category) & ~(1u << 31u)
            let bid = uint(b.ctx.category) & ~(1u << 31u)
            return aid < bid
        // TODO: send `threads` event
        return true

    def removeContext(var ctx: Context): void
        let idx = self->getContextIdx(ctx)
        if idx >= 0
            self->removeContextIdx(idx)

    def removeContextIdx(idx: int)
        delete contexts[idx]
        contexts |> erase(idx)

class private DAServer: Server
    port: int
    [[do_not_delete]] agent: DAgent?

    disconnected: bool = false

    // message data
    current_string: array<uint8>
    toRead: int = 0

    initialized: int = -1 // initialized event: ticks delay
    configurationDone: bool = false
    threadsDone: bool = false

    def DAServer
        Server`Server(cast<Server> self)

    def override onError(msg:string; code:int)
        print("[E] dap: server error:{code} - {msg}\n")

    def override onConnect()
        print("dap: connected ::{port}\n")

    def override onDisconnect()
        if length(current_string) > 0
            print(string(current_string))
            current_string |> clear()
        // print("disconnected\n")

    def restart()
        if _server != null
            var session : smart_ptr<NetworkServer>
            self->save(session)
            gc0_save_smart_ptr("telnet-session", session)

    def override tick()
        Server`tick(self)
        if initialized > 0
            initialized -= 1
            if initialized == 0
                self->sendEvent("initialized", null)

    def override onData(message:uint8?; size:int)
        for i in range(size)
            var uch : uint8
            unsafe
                uch = message[i]
            let ch = int(uch)
            if toRead == 0
                push(current_string, uch)
                let prefix = "Content-Length: "
                if length(current_string) <= length(prefix)
                    continue
                if ch != '\n'
                    continue
                var str = string(current_string)
                if str |> starts_with(prefix)
                    unsafe
                        var lenStr = chop(str, 16, length(current_string) - length(prefix) - 2) // \r\n length
                        toRead = to_int(lenStr)
                        clear(current_string)
                continue
            if ch == '\n' || ch == '\r'
                continue
            push(current_string, uch)
            if length(current_string) < toRead
                continue
            toRead = 0
            var error : string
            var msg = json::read_json(current_string, error)
            defer <| $
                unsafe
                    delete msg
            clear(current_string)
            self->log(">>>\n\n{write_json(msg)}\n\n")

            if msg.value is _object
                let seq = msg |> jon("seq", 0lf)
                let typ = msg |> jos("type", "n/a")
                if typ == "request"
                    let command = msg |> jos("command", "n/a")
                    let arguments = msg |> joj("arguments")
                    if command == "initialize"
                        self->reqInitialize(seq, command, arguments)
                    elif command == "configurationDone"
                        self->reqConfigurationDone(seq, command, arguments)
                    elif command == "disconnect"
                        self->reqDisconnect(seq, command, arguments)
                    elif command == "terminate"
                        self->reqTerminate(seq, command, arguments)
                    elif command == "launch"
                        self->reqLaunch(seq, command, arguments)
                    elif command == "attach"
                        self->reqAttach(seq, command, arguments)
                    elif command == "setBreakpoints"
                        self->reqSetBreakpoints(seq, command, arguments)
                    elif command == "threads"
                        self->reqThreads(seq, command, arguments)
                    elif command == "stackTrace"
                        self->reqStackTrace(seq, command, arguments)
                    elif command == "scopes"
                        self->reqScopes(seq, command, arguments)
                    elif command == "variables"
                        self->reqVariables(seq, command, arguments)
                    elif command == "continue"
                        self->reqContinue(seq, command, arguments)
                    elif command == "pause"
                        self->reqPause(seq, command, arguments)
                    elif command == "stepIn"
                        self->reqStepIn(seq, command, arguments)
                    elif command == "next"
                        self->reqNext(seq, command, arguments)
                    elif command == "stepOut"
                        self->reqStepOut(seq, command, arguments)
                    else
                        self->log("[Error] unknown request message\n{write_json(msg)}\n")
            else
                self->log("[Error] unknown message\n{write_json(msg)}\n")

    def reqInitialize(seq: double; command: string; arguments: JsonValue?)
        // var ini <- InitializeRequestArguments(arguments)
        // defer_delete(ini)
        var res = [[Capabilities
                                supportsConfigurationDoneRequest=true,
                                supportsRestartRequest=false,
                                supportTerminateDebuggee=true,
                                supportsTerminateRequest=true,
                                supportsExceptionOptions=false,
                                supportsExceptionFilterOptions=false
                                // supportsDelayedStackTraceLoading=true
                    ]]
        defer_delete(res)
        self->sendSuccessResponse(seq, command, JV(res))
        initialized = 100
        // self->sendEvent("initialized")

    def reqConfigurationDone(seq: double; command: string; data: JsonValue?)
        configurationDone = true
        self->sendSuccessResponse(seq, command, null)

    def reqLaunch(seq: double; command: string; data: JsonValue?)
        self->sendSuccessResponse(seq, command, null)

    def reqAttach(seq: double; command: string; data: JsonValue?)
        self->sendSuccessResponse(seq, command, null)

    def reqDisconnect(seq: double; command: string; data: JsonValue?)
        // var ini = DisconnectRequest(data)
        // defer_delete(ini)
        self->sendSuccessResponse(seq, command, null)
        for ctx in agent.contexts
            ctx |> reset_debug_flags()
            ctx.continueRequested = true
        for data in values(agent.breakpoints)
            delete data
        agent.breakpoints |> clear()
        // ini.arguments.restart
        disconnected = true

    def reqTerminate(seq: double; command: string; data: JsonValue?)
        self->sendSuccessResponse(seq, command, null)
        unsafe
            fio::exit(0)

    def reqSetBreakpoints(seq: double; command: string; data: JsonValue?)
        var ini <- SetBreakpointsArguments(data)
        defer_delete(ini)
        var res: SetBreakpointsResponse
        defer_delete(res)
        let path = ini.source.path
        if key_exists(agent.breakpoints, path)
            delete agent.breakpoints[path]
        agent.breakpoints |> erase(path)
        if length(ini.breakpoints) >= 0
            var breaks <- [[array<DABreakpoint>]]
            for b in ini.breakpoints
                breaks |> emplace([[DABreakpoint line=uint(b.line), id=agent.breakpointId ]])
                res.breakpoints |> emplace([[Breakpoint
                    verified=true,
                    id=double(agent.breakpointId),
                    source=ini.source,
                    line=b.line,
                    message="breakpoint #{int(agent.breakpointId)} {path}:{int(b.line)}"
                ]])
                agent.breakpointId += 1ul
            agent.breakpoints[path] <- breaks
        self->sendSuccessResponse(seq, command, JV(res))

    def reqThreads(seq: double; command: string; data: JsonValue?)
        var res: ThreadsResponseBody
        defer_delete(res)
        threadsDone = true
        for ctx in agent.contexts
            res.threads |> emplace([[Thread id=double(ctx.id), name=ctx |> to_string() ]])
        self->sendSuccessResponse(seq, command, JV(res))

    def reqStackTrace(seq: double; command: string; data: JsonValue?)
        var ini <- StackTraceArguments(data)
        defer_delete(ini)
        var res: StackTraceResponseBody
        defer_delete(res)
        agent->getContextData(uint64(ini.threadId)) <| $(var ctxData: DAContext)
            for idx, line in range(ini.levels), ctxData.stack
                res.stackFrames |> emplace([[StackFrame
                    id=double(ctxData.id * MAX_STACK + uint64(idx)),
                    name=line.name,
                    line=double(line.line),
                    column=1lf,
                    source=[[Source name=line.path, path=line.path]]
                ]])
            res.totalFrames = double(length(ctxData.stack))
        self->sendSuccessResponse(seq, command, JV(res))

    def reqScopes(seq: double; command: string; data: JsonValue?)
        var ini <- ScopesArguments(data)
        defer_delete(ini)
        var res: ScopesResponseBody
        defer_delete(res)
        let ctxId = uint64(ini.frameId / double(MAX_STACK))
        agent->getContextData(ctxId) <| $(var ctxData: DAContext)
            let frameId = int(ini.frameId % double(MAX_STACK))
            if frameId >= 0 && frameId < length(ctxData.stack)
                let line & = ctxData.stack[frameId]
                if length(line.variables) > 0
                    res.scopes |> emplace([[Scope
                        name="Locals",
                        variablesReference=double(uint64(ini.frameId) * MAX_VARIABLES + LOCAL_VARS)
                    ]])
                if length(line.arguments) > 0
                    res.scopes |> emplace([[Scope
                        name="Arguments",
                        variablesReference=double(uint64(ini.frameId) * MAX_VARIABLES + ARGUMENT_VARS)
                    ]])
                if get_total_variables(*ctxData.ctx) > 0
                    res.scopes |> emplace([[Scope
                        name="Globals",
                        variablesReference=double(uint64(ini.frameId) * MAX_VARIABLES + GLOBAL_VARS)
                    ]])
        self->sendSuccessResponse(seq, command, JV(res))

    def reqVariables(seq: double; command: string; data: JsonValue?)
        var ini <- VariablesArguments(data)
        defer_delete(ini)
        var res: VariablesResponseBody
        defer_delete(res)
        let ctxAndFrame = uint64(ini.variablesReference) / MAX_VARIABLES
        let ctxId = uint64(ctxAndFrame) / MAX_STACK
        agent->getContextData(ctxId) <| $(var ctxData: DAContext)
            let frameId = int(ctxAndFrame % MAX_STACK)
            if frameId >= 0 && frameId < length(ctxData.stack)
                let kind = uint64(ini.variablesReference) % MAX_VARIABLES
                let line & = ctxData.stack[frameId]
                if kind == LOCAL_VARS || kind == ARGUMENT_VARS || kind == GLOBAL_VARS
                    let vars & = kind == LOCAL_VARS ? line.variables : kind == ARGUMENT_VARS ? line.arguments : line.globals
                    for v in vars
                        let ref = v.children != null ? ctxAndFrame * MAX_VARIABLES + v.uid : 0ul
                        res.variables |> emplace([[Variable
                            name=v.name,
                            value=v.value,
                            _type=v._type,
                            variablesReference=double(ref)
                        ]])
                else
                    line |> find_child_var(uint64(kind)) <| $(child)
                        if child.children != null
                            for v in *child.children
                                let ref = v.children != null ? ctxAndFrame * MAX_VARIABLES + v.uid : 0ul
                                res.variables |> emplace([[Variable
                                    name=v.name,
                                    value=v.value,
                                    _type=v._type,
                                    variablesReference=double(ref)
                                ]])
        self->sendSuccessResponse(seq, command, JV(res))

    def reqContinue(seq: double; command: string; data: JsonValue?)
        var ini <- ContinueArguments(data)
        defer_delete(ini)
        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)
            ctx |> reset_debug_flags()
            ctx.continueRequested = true
        self->sendSuccessResponse(seq, command, null)

    def reqPause(seq: double; command: string; data: JsonValue?)
        var ini <- PauseArguments(data)
        defer_delete(ini)
        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)
            ctx |> reset_debug_flags()
            ctx.pauseRequested = true
        self->sendSuccessResponse(seq, command, null)

    def reqStepIn(seq: double; command: string; data: JsonValue?)
        var ini <- StepInArguments(data)
        defer_delete(ini)
        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)
            ctx |> reset_debug_flags()
            ctx.stepInRequested = true
        self->sendSuccessResponse(seq, command, null)

    def reqNext(seq: double; command: string; data: JsonValue?)
        var ini <- NextArguments(data)
        defer_delete(ini)
        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)
            ctx |> reset_debug_flags()
            ctx.stepRequestedStack = stack_depth(*ctx.ctx)
            ctx.stepInRequested = ctx.stepRequestedStack == 0
        self->sendSuccessResponse(seq, command, null)

    def reqStepOut(seq: double; command: string; data: JsonValue?)
        var ini <- NextArguments(data)
        defer_delete(ini)
        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)
            ctx |> reset_debug_flags()
            ctx.stepRequestedStack = max(stack_depth(*ctx.ctx) - 1, 0)
            ctx.stepInRequested = ctx.stepRequestedStack == 0
        self->sendSuccessResponse(seq, command, null)


    def log(msg: string)
        // print("{msg}\n")
        if self->is_connected()
            self->sendOutput("console", "{msg}\n")

    def sendOutput(category: string; output: string)
        var res = [[OutputEventBody category=category, output=output ]]
        defer_delete(res)
        self->sendRawData(JV({{"type"=>JV("event"); "event"=>JV("output"); "body"=>JV(res)}}), /*log*/false)

    def sendEvent(event: string; body: JsonValue?)
        self->sendRawData(JV({{"type"=>JV("event"); "event"=>JV(event); "body"=>body}}), /*log*/true)

    def sendSuccessResponse(id: double; command: string; body: JsonValue?)
        self->sendRawData(JV({{"request_seq"=>JV(id); "type"=>JV("response");
                                "body"=>body; "command"=>JV(command); "success"=>JV(true)}}), /*log*/true)

    // https://microsoft.github.io/language-server-protocol/specifications/specification-current/#responseMessage
    def sendRawData(var data : JsonValue?; logData: bool)
        var msg = write_json(data)
        var packStr = "Content-Length: {length(msg)}\r\n\r\n{msg}"
        if logData
            self->log("<------\n{packStr}")
        // else
        //     print("<------\n{packStr}\n")
        unsafe
            self->send(reinterpret<uint8?> packStr, length(packStr))
            delete data

    def sendStopped(ctx: DAContext; reason: string; brId: uint64)
        self->sendEvent("stopped", JV({{
            "reason"=>JV(reason);
            "threadId"=>JV(double(ctx.id));
            "allThreadsStopped"=>JV(false);
            "hitBreakpointIds"=>brId == -1ul ? null : JV([{auto[] JV(brId)}])
        }}))


[export,unused_argument(ctx)]
def private start_debug_agent(ctx: Context)
    install_new_debug_agent(new DAgent(), "debug")


[export]
def private start_agent(force:bool = false): bool
    if force || !has_debug_agent_context("debug")
        fork_debug_agent_context(@@start_debug_agent)
        print("dap: install debug agent\n")
    else
        print("dap: debug agent already exists\n")
    set_single_step(this_context(), true)
    return true


[init,export]
def private auto_start_debug()
    if !is_in_debug_agent_creation()
        this_context().category |= bitfield(1u << 31u) // TODO:
        set_single_step(this_context(), true)
        if !has_debug_agent_context("debug")
            if start_agent()
                new_thread <| @
                    this_context().category &= ~bitfield(1u << 31u) // TODO:
                    set_single_step(this_context(), false)
                    this_context().name := "tick thread"
                    while !is_job_que_shutting_down()
                        tick_debug_agent()
                        sleep(1u)
